[{"name": "app.py", "content": "from pathlib import Path\n\nimport matplotlib as mpl\nfrom matplotlib import ticker\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport regex as re\nfrom shiny import App, reactive, render, ui\n\n# We don't use Jinja2 directly in the app, but without the import, shinylive currently\n# doesn't bundle Jinja2's wheel and the library therefore fails to load.\nimport jinja2\n\nre.DEFAULT_VERSION = re.VERSION1\nmpl.rcParams.update(\n    {\n        \"figure.dpi\": 300,\n        \"axes.grid\": True,\n        \"axes.grid.axis\": \"both\",\n        \"grid.color\": \"gainsboro\",\n        \"axes.spines.left\": False,\n        \"axes.spines.right\": False,\n        \"axes.spines.top\": False,\n        \"axes.spines.bottom\": False,\n    }\n)\n\napp_ui = ui.page_fluid(\n    ui.br(),\n    ui.layout_sidebar(\n        ui.panel_sidebar(\n            ui.markdown(next(Path(\".\").rglob(\"README.md\")).read_text(\"utf-8\")),\n            ui.input_text_area(\"text\", \"Text to analyze\"),\n            ui.input_text(\"words\", \"Words to find in text\"),\n            ui.row(\n                ui.input_checkbox(\"icase\", \"Ignore case\"),\n                ui.input_checkbox(\"regex\", \"Regular expressions\"),\n            ),\n        ),\n        ui.panel_main(\n            ui.output_plot(\"dispersion_plot\"),\n            ui.output_table(\"freq_dist\"),\n        ),\n    ),\n    title=\"Lexical dispersion plot\",\n)\n\n\ndef tokenize(text):\n    return re.findall(\n        r\"\\p{Alphabetic}+(?:\\S+\\p{Alphabetic}+)*|[\\S&&\\P{Alphabetic}]+\",\n        text,\n        flags=re.VERSION1,\n    )\n\n\ndef warn(id, msg, **notification_show_kwargs):\n    # NOTE: duration=None should leave the notification around indefinitely, but\n    # currently doesn't, see https://github.com/rstudio/py-shiny/issues/257\n    ui.notification_show(\n        **notification_show_kwargs, ui=msg, id=id, type=\"warning\", duration=None\n    )\n\n\ndef server(input, output, session):\n    @reactive.Calc\n    def tokenize_text():\n        text = input.text().strip()\n        if not text:\n            warn(\"no-text\", \"Please provide an input text.\")\n            return []\n        ui.notification_remove(\"no-text\")\n        if input.icase() and not input.regex():\n            text = text.lower()\n        return tokenize(text)\n\n    @reactive.Calc\n    def word2y():\n        words = input.words().strip()\n        if not words:\n            warn(\"no-words\", \"Please provide words to plot.\")\n            return {}\n        ui.notification_remove(\"no-words\")\n        if input.icase() and not input.regex():\n            words = words.lower()\n        return {w: i for i, w in enumerate(reversed(words.split()))}\n\n    @reactive.Calc\n    def analyze():\n        text = tokenize_text()\n        words = word2y()\n        if not (text and words):\n            return\n\n        if input.regex():\n            # Map assigned group name to corresponding regex. The matched group's name\n            # will be available via Match.lastgroup, and so this will allow us to figure\n            # out which regex actually matched.\n            group2re: dict[str | None, str] = {f\"g{i}\": r for i, r in enumerate(words)}\n            pat = re.compile(\n                \"|\".join(f\"(?P<{g}>{r})\" for g, r in group2re.items()),\n                flags=re.IGNORECASE if input.icase() else 0,\n            )\n\n            def match(tok: str) -> str | None:\n                if (m := pat.fullmatch(tok)) is not None:\n                    return group2re[m.lastgroup]\n\n        else:\n\n            def match(tok: str) -> str | None:\n                if tok in words:\n                    return tok\n\n        xs = []\n        ys = []\n        freq_dist = {w: 0 for w in words}\n        for x, tok in enumerate(text):\n            if (word := match(tok)) is not None:\n                xs.append(x)\n                ys.append(words[word])\n                freq_dist[word] += 1\n        if not (xs and ys):\n            warn(\"no-result\", \"None of the words were found.\")\n            return\n        ui.notification_remove(\"no-result\")\n\n        return xs, ys, freq_dist\n\n    @output\n    @render.plot(alt=\"Dispersion plot of chosen words in input text\")\n    def dispersion_plot():\n        if (analysis := analyze()) is None:\n            return\n        xs, ys, freq_dist = analysis\n        fig, ax = plt.subplots()\n        ax.plot(xs, ys, marker=\"|\", markersize=20, linestyle=\"\")\n        ax.set_xlabel(\"Word offset\")\n        ax.xaxis.set_major_formatter(ticker.StrMethodFormatter(\"{x:,.0f}\"))\n        ax.set_yticks(range(len(freq_dist)), labels=list(freq_dist))\n        ax.set_ylim(-1, len(freq_dist))\n        ax.tick_params(axis=\"both\", length=0)\n        return fig\n\n    @output\n    @render.table()\n    def freq_dist():\n        if (analysis := analyze()) is None:\n            return\n        _, _, freq_dist = analysis\n        df = pd.DataFrame(freq_dist.items(), columns=[\"word\", \"frequency\"]).sort_values(\n            [\"frequency\", \"word\"], ascending=False\n        )\n        return df\n\n\napp = App(app_ui, server)\n", "type": "text"}, {"name": "Makefile", "content": ".PHONY: export deploy clean serve\n\ngenerated := app.json edit/ index.html shinylive/ shinylive-sw.js\n\nexport: clean\n\tshinylive export . site\n\tmv -t . site/*\n\trmdir site\n\ndeploy: export\n\tgit branch -D deploy\n\tgit checkout -b deploy\n\tgit add $(generated)\n\tgit commit -m Deploy\n\tgit push --force-with-lease -u origin deploy\n\tgit checkout master\n\nclean:\n\trm -rf $(generated)\n\nserve:\n\tpython3 -m http.server --bind localhost 8008\n", "type": "text"}, {"name": "README.md", "content": "Lexical dispersion plots with Shiny for Python\n==============================================\n\nA simple demo app for visualizing lexical dispersion plots, implemented using [Shiny for\nPython](https://shiny.rstudio.com/py/). The layout of the plot is inspired by the same\nfunctionality in [NLTK](https://www.nltk.org/_modules/nltk/draw/dispersion.html).\n\nYou can:\n\n- [try the app](https://dlukes.github.io/shiny-lexical-dispersion/) (it runs directly on\n  the client, i.e. in your browser, thanks to\n  [Shinylive](https://shiny.rstudio.com/py/docs/shinylive.html))\n- [tweak the source code of the app and reload your\n  changes](https://dlukes.github.io/shiny-lexical-dispersion/edit) directly in your\n  browser\n- [browse the source code](https://github.com/dlukes/shiny-lexical-dispersion/) on\n  GitHub\n- [learn\n  more](https://dlukes.github.io/shiny-lexical-dispersion/faster-regex-search.html)\n  about an optimization in the regex search feature\n", "type": "text"}, {"name": "faster-regex-search.html", "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<!-- 2022-12-04 Sun 23:23 -->\n<meta charset=\"utf-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Faster Regex Search</title>\n<meta name=\"author\" content=\"David Luke\u0161\" />\n<meta name=\"generator\" content=\"Org Mode\" />\n<style>\n  #content { max-width: 60em; margin: auto; }\n  .title  { text-align: center;\n             margin-bottom: .2em; }\n  .subtitle { text-align: center;\n              font-size: medium;\n              font-weight: bold;\n              margin-top:0; }\n  .todo   { font-family: monospace; color: red; }\n  .done   { font-family: monospace; color: green; }\n  .priority { font-family: monospace; color: orange; }\n  .tag    { background-color: #eee; font-family: monospace;\n            padding: 2px; font-size: 80%; font-weight: normal; }\n  .timestamp { color: #bebebe; }\n  .timestamp-kwd { color: #5f9ea0; }\n  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }\n  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }\n  .org-center { margin-left: auto; margin-right: auto; text-align: center; }\n  .underline { text-decoration: underline; }\n  #postamble p, #preamble p { font-size: 90%; margin: .2em; }\n  p.verse { margin-left: 3%; }\n  pre {\n    border: 1px solid #e6e6e6;\n    border-radius: 3px;\n    background-color: #f2f2f2;\n    padding: 8pt;\n    font-family: monospace;\n    overflow: auto;\n    margin: 1.2em;\n  }\n  pre.src {\n    position: relative;\n    overflow: auto;\n  }\n  pre.src:before {\n    display: none;\n    position: absolute;\n    top: -8px;\n    right: 12px;\n    padding: 3px;\n    color: #555;\n    background-color: #f2f2f299;\n  }\n  pre.src:hover:before { display: inline; margin-top: 14px;}\n  /* Languages per Org manual */\n  pre.src-asymptote:before { content: 'Asymptote'; }\n  pre.src-awk:before { content: 'Awk'; }\n  pre.src-authinfo::before { content: 'Authinfo'; }\n  pre.src-C:before { content: 'C'; }\n  /* pre.src-C++ doesn't work in CSS */\n  pre.src-clojure:before { content: 'Clojure'; }\n  pre.src-css:before { content: 'CSS'; }\n  pre.src-D:before { content: 'D'; }\n  pre.src-ditaa:before { content: 'ditaa'; }\n  pre.src-dot:before { content: 'Graphviz'; }\n  pre.src-calc:before { content: 'Emacs Calc'; }\n  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }\n  pre.src-fortran:before { content: 'Fortran'; }\n  pre.src-gnuplot:before { content: 'gnuplot'; }\n  pre.src-haskell:before { content: 'Haskell'; }\n  pre.src-hledger:before { content: 'hledger'; }\n  pre.src-java:before { content: 'Java'; }\n  pre.src-js:before { content: 'Javascript'; }\n  pre.src-latex:before { content: 'LaTeX'; }\n  pre.src-ledger:before { content: 'Ledger'; }\n  pre.src-lisp:before { content: 'Lisp'; }\n  pre.src-lilypond:before { content: 'Lilypond'; }\n  pre.src-lua:before { content: 'Lua'; }\n  pre.src-matlab:before { content: 'MATLAB'; }\n  pre.src-mscgen:before { content: 'Mscgen'; }\n  pre.src-ocaml:before { content: 'Objective Caml'; }\n  pre.src-octave:before { content: 'Octave'; }\n  pre.src-org:before { content: 'Org mode'; }\n  pre.src-oz:before { content: 'OZ'; }\n  pre.src-plantuml:before { content: 'Plantuml'; }\n  pre.src-processing:before { content: 'Processing.js'; }\n  pre.src-python:before { content: 'Python'; }\n  pre.src-R:before { content: 'R'; }\n  pre.src-ruby:before { content: 'Ruby'; }\n  pre.src-sass:before { content: 'Sass'; }\n  pre.src-scheme:before { content: 'Scheme'; }\n  pre.src-screen:before { content: 'Gnu Screen'; }\n  pre.src-sed:before { content: 'Sed'; }\n  pre.src-sh:before { content: 'shell'; }\n  pre.src-sql:before { content: 'SQL'; }\n  pre.src-sqlite:before { content: 'SQLite'; }\n  /* additional languages in org.el's org-babel-load-languages alist */\n  pre.src-forth:before { content: 'Forth'; }\n  pre.src-io:before { content: 'IO'; }\n  pre.src-J:before { content: 'J'; }\n  pre.src-makefile:before { content: 'Makefile'; }\n  pre.src-maxima:before { content: 'Maxima'; }\n  pre.src-perl:before { content: 'Perl'; }\n  pre.src-picolisp:before { content: 'Pico Lisp'; }\n  pre.src-scala:before { content: 'Scala'; }\n  pre.src-shell:before { content: 'Shell Script'; }\n  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }\n  /* additional language identifiers per \"defun org-babel-execute\"\n       in ob-*.el */\n  pre.src-cpp:before  { content: 'C++'; }\n  pre.src-abc:before  { content: 'ABC'; }\n  pre.src-coq:before  { content: 'Coq'; }\n  pre.src-groovy:before  { content: 'Groovy'; }\n  /* additional language identifiers from org-babel-shell-names in\n     ob-shell.el: ob-shell is the only babel language using a lambda to put\n     the execution function name together. */\n  pre.src-bash:before  { content: 'bash'; }\n  pre.src-csh:before  { content: 'csh'; }\n  pre.src-ash:before  { content: 'ash'; }\n  pre.src-dash:before  { content: 'dash'; }\n  pre.src-ksh:before  { content: 'ksh'; }\n  pre.src-mksh:before  { content: 'mksh'; }\n  pre.src-posh:before  { content: 'posh'; }\n  /* Additional Emacs modes also supported by the LaTeX listings package */\n  pre.src-ada:before { content: 'Ada'; }\n  pre.src-asm:before { content: 'Assembler'; }\n  pre.src-caml:before { content: 'Caml'; }\n  pre.src-delphi:before { content: 'Delphi'; }\n  pre.src-html:before { content: 'HTML'; }\n  pre.src-idl:before { content: 'IDL'; }\n  pre.src-mercury:before { content: 'Mercury'; }\n  pre.src-metapost:before { content: 'MetaPost'; }\n  pre.src-modula-2:before { content: 'Modula-2'; }\n  pre.src-pascal:before { content: 'Pascal'; }\n  pre.src-ps:before { content: 'PostScript'; }\n  pre.src-prolog:before { content: 'Prolog'; }\n  pre.src-simula:before { content: 'Simula'; }\n  pre.src-tcl:before { content: 'tcl'; }\n  pre.src-tex:before { content: 'TeX'; }\n  pre.src-plain-tex:before { content: 'Plain TeX'; }\n  pre.src-verilog:before { content: 'Verilog'; }\n  pre.src-vhdl:before { content: 'VHDL'; }\n  pre.src-xml:before { content: 'XML'; }\n  pre.src-nxml:before { content: 'XML'; }\n  /* add a generic configuration mode; LaTeX export needs an additional\n     (add-to-list 'org-latex-listings-langs '(conf \" \")) in .emacs */\n  pre.src-conf:before { content: 'Configuration File'; }\n\n  table { border-collapse:collapse; }\n  caption.t-above { caption-side: top; }\n  caption.t-bottom { caption-side: bottom; }\n  td, th { vertical-align:top;  }\n  th.org-right  { text-align: center;  }\n  th.org-left   { text-align: center;   }\n  th.org-center { text-align: center; }\n  td.org-right  { text-align: right;  }\n  td.org-left   { text-align: left;   }\n  td.org-center { text-align: center; }\n  dt { font-weight: bold; }\n  .footpara { display: inline; }\n  .footdef  { margin-bottom: 1em; }\n  .figure { padding: 1em; }\n  .figure p { text-align: center; }\n  .equation-container {\n    display: table;\n    text-align: center;\n    width: 100%;\n  }\n  .equation {\n    vertical-align: middle;\n  }\n  .equation-label {\n    display: table-cell;\n    text-align: right;\n    vertical-align: middle;\n  }\n  .inlinetask {\n    padding: 10px;\n    border: 2px solid gray;\n    margin: 10px;\n    background: #ffffcc;\n  }\n  #org-div-home-and-up\n   { text-align: right; font-size: 70%; white-space: nowrap; }\n  textarea { overflow-x: auto; }\n  .linenr { font-size: smaller }\n  .code-highlighted { background-color: #ffff00; }\n  .org-info-js_info-navigation { border-style: none; }\n  #org-info-js_console-label\n    { font-size: 10px; font-weight: bold; white-space: nowrap; }\n  .org-info-js_search-highlight\n    { background-color: #ffff00; color: #000000; font-weight: bold; }\n  .org-svg { }\n</style>\n<style>\nhtml {\n  --fg: #333;\n  --fg-light: #999;\n  --bg: #fafafa;\n  --hi: #4169e1; /* royalblue */\n  transition: filter .5s ease;\n}\nhtml.dark {\n  filter: invert(.9);\n}\nbody {\n  font-family: sans-serif;\n  line-height: 1.5;\n  background-color: var(--bg);\n  color: var(--fg);\n  display: flex;\n  flex-flow: row wrap;\n  align-items: flex-start;\n  justify-content: center;\n  gap: 1rem;\n}\n#preamble, #postamble {\n  position: sticky;\n  top: 1rem;\n}\n#lights {\n  cursor: pointer;\n}\n#table-of-contents ul {\n  list-style-type: none;\n  padding-left: 0;\n}\n#content {\n  max-width: 40rem;\n  margin: revert;\n  overflow: auto;\n}\n\n/* Various kinds of links. */\na {\n  color: var(--hi);\n  text-decoration: none;\n}\na:hover {\n  text-decoration: underline;\n}\n:is(h1, h2, h3, h4, h5, h6) a {\n  color: var(--fg);\n  text-decoration: none;\n}\n:is(h1, h2, h3, h4, h5, h6) a:hover {\n  text-decoration: none;\n}\n:is(h1, h2, h3, h4, h5, h6) a:hover::after {\n  content: ' \u00a7';\n  color: var(--fg-light);\n}\n#table-of-contents a {\n  color: var(--fg-light);\n}\n#table-of-contents a:hover {\n  color: var(--hi);\n  text-decoration: none;\n}\n\n/* Source blocks. */\npre.src {\n  counter-reset: line;\n  padding-left: 0;\n}\npre.src code::before {\n  counter-increment: line;\n  content: counter(line);\n  color: var(--fg-light);\n  width: 2em;\n  display: inline-block;\n  text-align: right;\n  padding-right: .5em;\n  margin-right: .5em;\n  border-right: 1px solid #bbb;\n}\n\n/* Figures. */\n.figure img {\n  max-width: 100%;\n}\n</style>\n<script>\nfunction darkModeToggle() {\n  var dark = 'dark';\n  var dcl = document.documentElement.classList;\n  var lights = document.getElementById('lights');\n  if (dcl.contains(dark)) {\n    lights.innerHTML = '<svg fill=\"none\" viewBox=\"0 0 24 24\" width=\"24\" height=\"24\" stroke=\"currentColor\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z\"></path></svg>';\n    dcl.remove(dark);\n  } else {\n    lights.innerHTML = '<svg fill=\"none\" viewBox=\"0 0 24 24\" width=\"24\" height=\"24\" stroke=\"currentColor\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z\"></path></svg>';\n    dcl.add(dark);\n  }\n}\n\ndocument.addEventListener('DOMContentLoaded', function() {\n  if (window.matchMedia('(prefers-color-scheme: dark)').matches) {\n    darkModeToggle();\n  }\n  var toc = document.getElementById('table-of-contents');\n  if (toc !== null) {\n    document.getElementById('postamble').appendChild(toc);\n  }\n}, false);\n</script>\n<script>\n// @license magnet:?xt=urn:btih:1f739d935676111cfff4b4693e3816e664797050&amp;dn=gpl-3.0.txt GPL-v3-or-Later\n     function CodeHighlightOn(elem, id)\n     {\n       var target = document.getElementById(id);\n       if(null != target) {\n         elem.classList.add(\"code-highlighted\");\n         target.classList.add(\"code-highlighted\");\n       }\n     }\n     function CodeHighlightOff(elem, id)\n     {\n       var target = document.getElementById(id);\n       if(null != target) {\n         elem.classList.remove(\"code-highlighted\");\n         target.classList.remove(\"code-highlighted\");\n       }\n     }\n// @license-end\n</script>\n</head>\n<body>\n<div id=\"preamble\" class=\"status\">\n<span id=\"lights\" onclick=\"darkModeToggle()\"><svg fill=\"none\" viewBox=\"0 0 24 24\" width=\"24\" height=\"24\" stroke=\"currentColor\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z\"></path></svg></span>\n</div>\n<div id=\"content\" class=\"content\">\n<h1 class=\"title\">Faster Regex Search</h1>\n<div id=\"table-of-contents\" role=\"doc-toc\">\n<h2>Table of Contents</h2>\n<div id=\"text-table-of-contents\" role=\"doc-toc\">\n<ul>\n<li><a href=\"#orgb09ad99\">1. Task</a></li>\n<li><a href=\"#org1f46150\">2. Possible approaches</a>\n<ul>\n<li><a href=\"#orgb19b351\">2.1. Match list of regexes in nested for-loop</a></li>\n<li><a href=\"#org205eb19\">2.2. Build a union with named groups</a></li>\n</ul>\n</li>\n</ul>\n</div>\n</div>\n\n<div id=\"outline-container-orgb09ad99\" class=\"outline-2\">\n<h2 id=\"orgb09ad99\"><span class=\"section-number-2\">1.</span> <a href=\"#orgb09ad99\">Task</a></h2>\n<div class=\"outline-text-2\" id=\"text-1\">\n<p>\nStarting with a list of regexes and a list of tokens, try to match each of the regexes and store the first regex which matches, if any.\n</p>\n\n<p>\nNote: we want to store the regexes, not the strings that matched. This makes it non-trivial. If we just build a straightforward union regex out of the list of regexes, we won&rsquo;t know which part matched.\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"src src-jupyter-python\"><code><span style=\"color: #51afef;\">import</span> regex <span style=\"color: #51afef;\">as</span> re</code>\n<code><span style=\"color: #51afef;\">from</span> nltk.book <span style=\"color: #51afef;\">import</span> <span style=\"color: #51afef;\">*</span></code>\n<code></code>\n<code><span style=\"color: #dcaeea;\">regexes</span> <span style=\"color: #51afef;\">=</span> [<span style=\"color: #98be65;\">r\"(?i:elinor.*)\"</span>, <span style=\"color: #98be65;\">r\"(?i:marianne.*)\"</span>,</code>\n<code>           <span style=\"color: #98be65;\">r\"(?i:edward.*)\"</span>, <span style=\"color: #98be65;\">r\"(?i:willoughby.*)\"</span>, <span style=\"color: #98be65;\">r\"(?i:colonel.*)\"</span>]</code>\n<code>text2</code>\n</pre>\n</div>\n\n<pre class=\"example\">\n&lt;Text: Sense and Sensibility by Jane Austen 1811&gt;\n</pre>\n</div>\n</div>\n\n<div id=\"outline-container-org1f46150\" class=\"outline-2\">\n<h2 id=\"org1f46150\"><span class=\"section-number-2\">2.</span> <a href=\"#org1f46150\">Possible approaches</a></h2>\n<div class=\"outline-text-2\" id=\"text-2\">\n</div>\n<div id=\"outline-container-orgb19b351\" class=\"outline-3\">\n<h3 id=\"orgb19b351\"><span class=\"section-number-3\">2.1.</span> <a href=\"#orgb19b351\">Match list of regexes in nested for-loop</a></h3>\n<div class=\"outline-text-3\" id=\"text-2-1\">\n<p>\nPros: Straightforward.\n</p>\n\n<p>\nCons: Matching a list of regexes in a loop over and over is really slow compared to doing just one regex match per token, especially if the list is long and matches are found only seldom.\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"src src-jupyter-python\"><code><span style=\"color: #dcaeea;\">patterns</span> <span style=\"color: #51afef;\">=</span> [re.<span style=\"color: #51afef; font-weight: bold; font-style: italic;\">compile</span>(r) <span style=\"color: #51afef;\">for</span> <span style=\"color: #dcaeea;\">r</span> <span style=\"color: #51afef;\">in</span> regexes]</code>\n<code>patterns</code>\n</pre>\n</div>\n\n<pre class=\"example\">\n[regex.Regex('(?i:elinor.*)', flags=regex.F | regex.V1),\n regex.Regex('(?i:marianne.*)', flags=regex.F | regex.V1),\n regex.Regex('(?i:edward.*)', flags=regex.F | regex.V1),\n regex.Regex('(?i:willoughby.*)', flags=regex.F | regex.V1),\n regex.Regex('(?i:colonel.*)', flags=regex.F | regex.V1)]\n</pre>\n\n\n<div class=\"org-src-container\">\n<pre class=\"src src-jupyter-python\"><code><span style=\"color: #dcaeea;\">results</span> <span style=\"color: #51afef;\">=</span> []</code>\n</pre>\n</div>\n\n<div class=\"org-src-container\">\n<pre class=\"src src-jupyter-python\"><code><span style=\"color: #51afef;\">%%</span>timeit</code>\n<code><span style=\"color: #51afef;\">for</span> <span style=\"color: #dcaeea;\">token</span> <span style=\"color: #51afef;\">in</span> text2:</code>\n<code>    <span style=\"color: #51afef;\">for</span> <span style=\"color: #dcaeea;\">pat</span> <span style=\"color: #51afef;\">in</span> patterns:</code>\n<code>        <span style=\"color: #51afef;\">if</span> pat.<span style=\"color: #51afef; font-weight: bold; font-style: italic;\">match</span>(token):</code>\n<code>            results.<span style=\"color: #51afef; font-weight: bold; font-style: italic;\">append</span>(pat.<span style=\"color: #a9a1e1; font-style: italic;\">pattern</span>)</code>\n<code>            <span style=\"color: #51afef;\">break</span></code>\n</pre>\n</div>\n\n<pre class=\"example\">\n84.4 ms \u00b1 564 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 10 loops each)\n</pre>\n\n\n<div class=\"org-src-container\">\n<pre class=\"src src-jupyter-python\"><code><span style=\"color: #c678dd; font-weight: bold;\">len</span>(results), results[:<span style=\"color: #a9a1e1;\">10</span>]</code>\n</pre>\n</div>\n\n<pre class=\"example\" id=\"org20818b1\">\n<code>(154629,</code>\n<code> ['(?i:elinor.*)',</code>\n<code>  '(?i:marianne.*)',</code>\n<code>  '(?i:elinor.*)',</code>\n<code>  '(?i:elinor.*)',</code>\n<code>  '(?i:elinor.*)',</code>\n<code>  '(?i:marianne.*)',</code>\n<code>  '(?i:edward.*)',</code>\n<code>  '(?i:elinor.*)',</code>\n<code>  '(?i:elinor.*)',</code>\n<code>  '(?i:edward.*)'])</code>\n</pre>\n</div>\n</div>\n\n<div id=\"outline-container-org205eb19\" class=\"outline-3\">\n<h3 id=\"org205eb19\"><span class=\"section-number-3\">2.2.</span> <a href=\"#org205eb19\">Build a union with named groups</a></h3>\n<div class=\"outline-text-3\" id=\"text-2-2\">\n<p>\nPros: Only one regex match attempt per token.\n</p>\n\n<p>\nCons: Implemenation is a bit more involved and therefore error/bug-prone. In theory, group names can clash with group names entered by user. I could use UUIDs to make collisions extremely unlikely, but in practice, I don&rsquo;t think anyone will actually use named groups when entering regexes into this app. Also, the abstraction is a bit more leaky: the user thinks he&rsquo;s entering separate regexes, but since they all end up being concatenated to one, this affects the syntax that can be used: in particular, inline flags like <code>(?i)</code> can only appear at the start of a regular expression, so specifying a query like <code>foo (?i)bar</code> won&rsquo;t work. Still, these are all rather advanced features that even regular users of regular expressions often aren&rsquo;t aware of, so let&rsquo;s trade them for the performance improvement.\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"src src-jupyter-python\"><code><span style=\"color: #dcaeea;\">group2regex</span> <span style=\"color: #51afef;\">=</span> {<span style=\"color: #98be65;\">f\"g</span><span style=\"color: #51afef;\">{</span><span style=\"color: #bbc2cf; background-color: #282c34;\">i</span><span style=\"color: #51afef;\">}</span><span style=\"color: #98be65;\">\"</span>: r <span style=\"color: #51afef;\">for</span> <span style=\"color: #dcaeea;\">i</span>, <span style=\"color: #dcaeea;\">r</span> <span style=\"color: #51afef;\">in</span> <span style=\"color: #c678dd; font-weight: bold;\">enumerate</span>(regexes)}</code>\n<code><span style=\"color: #dcaeea;\">pat</span> <span style=\"color: #51afef;\">=</span> re.<span style=\"color: #51afef; font-weight: bold; font-style: italic;\">compile</span>(<span style=\"color: #98be65;\">\"|\"</span>.<span style=\"color: #51afef; font-weight: bold; font-style: italic;\">join</span>(<span style=\"color: #98be65;\">f\"(?P&lt;</span><span style=\"color: #51afef;\">{</span><span style=\"color: #bbc2cf; background-color: #282c34;\">g</span><span style=\"color: #51afef;\">}</span><span style=\"color: #98be65;\">&gt;</span><span style=\"color: #51afef;\">{</span><span style=\"color: #bbc2cf; background-color: #282c34;\">r</span><span style=\"color: #51afef;\">}</span><span style=\"color: #98be65;\">)\"</span> <span style=\"color: #51afef;\">for</span> <span style=\"color: #dcaeea;\">g</span>, <span style=\"color: #dcaeea;\">r</span> <span style=\"color: #51afef;\">in</span> group2regex.<span style=\"color: #51afef; font-weight: bold; font-style: italic;\">items</span>()))</code>\n<code>group2regex, pat</code>\n</pre>\n</div>\n\n<pre class=\"example\">\n({'g0': '(?i:elinor.*)',\n  'g1': '(?i:marianne.*)',\n  'g2': '(?i:edward.*)',\n  'g3': '(?i:willoughby.*)',\n  'g4': '(?i:colonel.*)'},\n regex.Regex('(?P&lt;g0&gt;(?i:elinor.*))|(?P&lt;g1&gt;(?i:marianne.*))|(?P&lt;g2&gt;(?i:edward.*))|(?P&lt;g3&gt;(?i:willoughby.*))|(?P&lt;g4&gt;(?i:colonel.*))', flags=regex.F | regex.V1))\n</pre>\n\n\n<div class=\"org-src-container\">\n<pre class=\"src src-jupyter-python\"><code><span style=\"color: #dcaeea;\">results</span> <span style=\"color: #51afef;\">=</span> []</code>\n<code>pat.<span style=\"color: #51afef; font-weight: bold; font-style: italic;\">match</span>(<span style=\"color: #98be65;\">\"Marianne's\"</span>)</code>\n</pre>\n</div>\n\n<pre class=\"example\">\n&lt;regex.Match object; span=(0, 10), match=\"Marianne's\"&gt;\n</pre>\n\n\n<div class=\"org-src-container\">\n<pre class=\"src src-jupyter-python\"><code><span style=\"color: #51afef;\">%%</span>timeit</code>\n<code><span style=\"color: #51afef;\">for</span> <span style=\"color: #dcaeea;\">token</span> <span style=\"color: #51afef;\">in</span> text2:</code>\n<code>    <span style=\"color: #51afef;\">if</span> (<span style=\"color: #dcaeea;\">m</span> := pat.<span style=\"color: #51afef; font-weight: bold; font-style: italic;\">match</span>(token)) <span style=\"color: #51afef;\">is</span> <span style=\"color: #51afef;\">not</span> <span style=\"color: #c678dd;\">None</span>:</code>\n<code>        results.<span style=\"color: #51afef; font-weight: bold; font-style: italic;\">append</span>(group2regex[m.<span style=\"color: #a9a1e1; font-style: italic;\">lastgroup</span>])</code>\n</pre>\n</div>\n\n<pre class=\"example\">\n26.7 ms \u00b1 294 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 10 loops each)\n</pre>\n\n\n<div class=\"org-src-container\">\n<pre class=\"src src-jupyter-python\"><code><span style=\"color: #c678dd; font-weight: bold;\">len</span>(results), results[:<span style=\"color: #a9a1e1;\">10</span>]</code>\n</pre>\n</div>\n\n<pre class=\"example\" id=\"org781db60\">\n<code>(154629,</code>\n<code> ['(?i:elinor.*)',</code>\n<code>  '(?i:marianne.*)',</code>\n<code>  '(?i:elinor.*)',</code>\n<code>  '(?i:elinor.*)',</code>\n<code>  '(?i:elinor.*)',</code>\n<code>  '(?i:marianne.*)',</code>\n<code>  '(?i:edward.*)',</code>\n<code>  '(?i:elinor.*)',</code>\n<code>  '(?i:elinor.*)',</code>\n<code>  '(?i:edward.*)'])</code>\n</pre>\n</div>\n</div>\n</div>\n</div>\n<div id=\"postamble\" class=\"status\">\n<p class=\"author\">Author: David Luke\u0161</p>\n<p class=\"date\">Created: 2022-12-04 Sun 23:23</p>\n<p class=\"creator\"><a href=\"https://www.gnu.org/software/emacs/\">Emacs</a> 28.2 (<a href=\"https://orgmode.org\">Org</a> mode 9.6)</p>\n</div>\n</body>\n</html>\n", "type": "text"}, {"name": "faster-regex-search.org", "content": "#+title: Faster Regex Search\n\n* Task\nStarting with a list of regexes and a list of tokens, try to match each of the regexes and store the first regex which matches, if any.\n\nNote: we want to store the regexes, not the strings that matched. This makes it non-trivial. If we just build a straightforward union regex out of the list of regexes, we won't know which part matched.\n\n#+begin_src jupyter-python\nimport regex as re\nfrom nltk.book import *\n\nregexes = [r\"(?i:elinor.*)\", r\"(?i:marianne.*)\",\n           r\"(?i:edward.*)\", r\"(?i:willoughby.*)\", r\"(?i:colonel.*)\"]\ntext2\n#+end_src\n\n#+RESULTS:\n: <Text: Sense and Sensibility by Jane Austen 1811>\n\n* Possible approaches\n** Match list of regexes in nested for-loop\nPros: Straightforward.\n\nCons: Matching a list of regexes in a loop over and over is really slow compared to doing just one regex match per token, especially if the list is long and matches are found only seldom.\n\n#+begin_src jupyter-python\npatterns = [re.compile(r) for r in regexes]\npatterns\n#+end_src\n\n#+RESULTS:\n: [regex.Regex('(?i:elinor.*)', flags=regex.F | regex.V1),\n:  regex.Regex('(?i:marianne.*)', flags=regex.F | regex.V1),\n:  regex.Regex('(?i:edward.*)', flags=regex.F | regex.V1),\n:  regex.Regex('(?i:willoughby.*)', flags=regex.F | regex.V1),\n:  regex.Regex('(?i:colonel.*)', flags=regex.F | regex.V1)]\n\n#+begin_src jupyter-python\nresults = []\n#+end_src\n\n#+RESULTS:\n\n#+begin_src jupyter-python\n%%timeit\nfor token in text2:\n    for pat in patterns:\n        if pat.match(token):\n            results.append(pat.pattern)\n            break\n#+end_src\n\n#+RESULTS:\n: 84.4 ms \u00b1 564 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 10 loops each)\n\n#+begin_src jupyter-python\nlen(results), results[:10]\n#+end_src\n\n#+RESULTS:\n#+begin_example\n(154629,\n ['(?i:elinor.*)',\n  '(?i:marianne.*)',\n  '(?i:elinor.*)',\n  '(?i:elinor.*)',\n  '(?i:elinor.*)',\n  '(?i:marianne.*)',\n  '(?i:edward.*)',\n  '(?i:elinor.*)',\n  '(?i:elinor.*)',\n  '(?i:edward.*)'])\n#+end_example\n\n** Build a union with named groups\nPros: Only one regex match attempt per token.\n\nCons: Implemenation is a bit more involved and therefore error/bug-prone. In theory, group names can clash with group names entered by user. I could use UUIDs to make collisions extremely unlikely, but in practice, I don't think anyone will actually use named groups when entering regexes into this app. Also, the abstraction is a bit more leaky: the user thinks he's entering separate regexes, but since they all end up being concatenated to one, this affects the syntax that can be used: in particular, inline flags like =(?i)= can only appear at the start of a regular expression, so specifying a query like =foo (?i)bar= won't work. Still, these are all rather advanced features that even regular users of regular expressions often aren't aware of, so let's trade them for the performance improvement.\n\n#+begin_src jupyter-python\ngroup2regex = {f\"g{i}\": r for i, r in enumerate(regexes)}\npat = re.compile(\"|\".join(f\"(?P<{g}>{r})\" for g, r in group2regex.items()))\ngroup2regex, pat\n#+end_src\n\n#+RESULTS:\n: ({'g0': '(?i:elinor.*)',\n:   'g1': '(?i:marianne.*)',\n:   'g2': '(?i:edward.*)',\n:   'g3': '(?i:willoughby.*)',\n:   'g4': '(?i:colonel.*)'},\n:  regex.Regex('(?P<g0>(?i:elinor.*))|(?P<g1>(?i:marianne.*))|(?P<g2>(?i:edward.*))|(?P<g3>(?i:willoughby.*))|(?P<g4>(?i:colonel.*))', flags=regex.F | regex.V1))\n\n#+begin_src jupyter-python\nresults = []\npat.match(\"Marianne's\")\n#+end_src\n\n#+RESULTS:\n: <regex.Match object; span=(0, 10), match=\"Marianne's\">\n\n#+begin_src jupyter-python\n%%timeit\nfor token in text2:\n    if (m := pat.match(token)) is not None:\n        results.append(group2regex[m.lastgroup])\n#+end_src\n\n#+RESULTS:\n: 26.7 ms \u00b1 294 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 10 loops each)\n\n#+begin_src jupyter-python\nlen(results), results[:10]\n#+end_src\n\n#+RESULTS:\n#+begin_example\n(154629,\n ['(?i:elinor.*)',\n  '(?i:marianne.*)',\n  '(?i:elinor.*)',\n  '(?i:elinor.*)',\n  '(?i:elinor.*)',\n  '(?i:marianne.*)',\n  '(?i:edward.*)',\n  '(?i:elinor.*)',\n  '(?i:elinor.*)',\n  '(?i:edward.*)'])\n#+end_example\n", "type": "text"}, {"name": "requirements.txt", "content": "Jinja2\n", "type": "text"}]